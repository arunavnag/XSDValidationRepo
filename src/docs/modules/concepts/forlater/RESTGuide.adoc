= REST API Guidelines

[[RESTAPIGuidelines-Abstract]]
== Abstract

Great# RESTful APIs look like they were designed by a single team. This promotes API adoption, reduces friction, and enables clients to use them properly. The following guideline targets to support developers to build APIs that meet this standard, and to answer many common questions encountered along the way of RESTful API development. Through unified REST APIs it is possible for developers to easier integrate other services. Thus, REST APIs should follow consistent design guidelines to make them easy and intuitive.

[[RESTAPIGuidelines-Introduction]]
== Introduction

The guidelines are based on https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md[Microsoft Rest guidelines] (Jan 11, 2019 - https://github.com/Microsoft/api-guidelines/commit/36224ba86f6a85c11ac5ae8e0a19830b2ff58bb1[commit hash]). Sections without any exception to the original are directly referring to the related section in the original document to avoid redundancy and to improve the readability of the guideline. Services and developers often access most resources via HTTP interfaces. Each service typically provides language-specific frameworks to include its APIs, thus all operations are ultimately reduced to HTTP requests. Each service SHOULD provide clients for an easier usage/integration of the API. However, you can not rely on having extensive frameworks or clients for each service. Therefore, the goal of these guidelines is to ensure that BCI REST APIs can be used consistently by any client with a simple HTTP support.

The following guideline MUST be followed for all new REST API and if possible also for existing APIs depending on the migration effort to ensure the best possible experience for consumers of our APIs/Products.

The intended goals to achieve are the following:

* Unified access to all BCI endpoints for developers and services
* As far as possible stick to the generally accepted best practice of REST/HTTP
* For developers, access via REST interfaces is easy
* Clients can be easily used and developed
* Partners and customers have a uniform operation of the REST endpoints

*Recommended reading*

* https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md#31-recommended-reading[Microsoft API Guidelines - Recommended Reading]
* https://developer.mozilla.org/en-US/docs/Web/HTTP/Status[HTTP response status codes] - Overview of valid HTTP response status code
* http://restcookbook.com/[Rest cookbook] – Tips for REST
* https://docs.microsoft.com/de-de/azure/architecture/best-practices/api-design[API-Design] – Best Practices from Microsoft
* http://standards.rest/[http://standards.rest] – A collection of standards and specifications, that help make fantastic HTTP/REST APIs
* https://blog.mwaysolutions.com/2014/06/05/10-best-practices-for-better-restful-api/[10 Best Practices for Better RESTful API] - Best Practices
* http://martinfowler.com/articles/richardsonMaturityModel.html[Richardson's maturity model for REST] - A model that breaks down the principal elements of a REST approach into three steps
* https://inside-docupedia.bosch.com/confluence/pages/viewpage.action?pageId=511466764[Development Guidelines - RESTful APIs (old version)]
* http://stateless.co/hal_specification.html[HAL - Hypertext Application Language]

[[RESTAPIGuidelines-Interpretingtheguidelines]]
== Interpreting the guidelines

As recommended by Microsoft https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md#4-interpreting-the-guidelines[here].

[[RESTAPIGuidelines-Taxonomy]]
== Taxonomy

As defined by Microsoft https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md#5-taxonomy[here].

[[RESTAPIGuidelines-Clientguidance]]
== Client guidance

As documented by Microsoft https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md#6-client-guidance[here].

[[RESTAPIGuidelines-Consistencyfundamentals]]
== Consistency fundamentals

[[RESTAPIGuidelines-URLstructure]]
=== URL structure

(Content published by Microsoft can be found https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md#71-url-structure[here].)

Additionally:

Default URL structure

[cols=",,"]
|===
a|

| |
|Path Element |Description |REQUIRED
|api-name |In case of multiple APIs with a potentially different resource structure, you SHOULD consider to use a speaking name for it. Default is `+api+` for the functional service API# |Haken]
|version |Version of the API# |Haken
|tenant-id |ID of the tenant. If a strict separation of the tenant should be enforced every time or not, the id be should be considered e.g. supporting a search across tenants or within a tenant. +
# |Fehler)]
|resource |Resource e.g. users or devices |Haken)]
|===

[[RESTAPIGuidelines-URLlength]]
=== URL length

(Content published by Microsoft can be found https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md#72-url-length[here].)

[[RESTAPIGuidelines-Supportedmethods]]
=== Supported methods

(Content published by Microsoft can be found https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md#74-supported-methods[here].)

Additionally:

* Avoid to use HEAD and `+OPTIONS+` they might not be well-supported by all libraries.
* For guidance whether to use `+POST+` or `+PUT+`, see https://stackoverflow.com/questions/630453/put-vs-post-in-rest
* `+PUT+` and `+PATCH+` without ID is not valid.

[[RESTAPIGuidelines-POSTwithoutid]]
==== POST without id

Creates a new resource according to the provided payload. The response code MUST be `+201+` Created and a full serialized entity including the id created by the service MUST be the returned. Only returning a subsets of properties is highly discouraged and SHOULD only be done for good reasons:

* It really is some sort of "data sink", i.e. it is in general absolutely not relevant for clients to get a mirrored response (this is not the case for a standard CRUD API, it might be the case for the submission of some message).
* It really is critical from a performance point of view to not return the fully serialized result object (this is not the case for some entity with 10 properties, it might be relevant with 50 properties, some of them being sub-resources).

Further, the response MAY contain the URL of the created resource in the Location header.

[[RESTAPIGuidelines-POSTwithid]]
==== POST with id

`+POST+` with an ID is not allowed and the service MUST return `+400+` Bad Request.

[[RESTAPIGuidelines-PUTwithid]]
==== PUT with id#


===== Resource doesn't exist

Creates a new resource according to the provided payload. This is only allowed for the case where it is mandatory that the client supplies the ID. The response code MUST be `+201+` Created and the response MUST contain the full serialized entity (see "POST without ID").

[[RESTAPIGuidelines-Resourcealreadyexists]]
===== Resource already exists

Modifies/updates the existing resource by replacing the complete resource with provided payload. The response code MUST be `+200+` OK and the response MUST contain the full serialized entity (see "POST without ID"). A `+PUT+` with an ID if the resource does not exist (and the above described case of resource creation does not apply) MUST be handled as a failure returning a `+404+` Resource not found.

[[RESTAPIGuidelines-PATCH]]
==== PATCH

Partially updates the resource according to the provided payload. The payload MAY consist of a partial object or if supported by the service a structure/format according to http://jsonpatch.com/[JSON Patch] (see chapter "PATCH Operations"). +
The response MUST be `+200+` OK and MUST contain the full serialized entity (see "POST without ID").

`+PATCH+` operations can be either offered using partial objects or JSON Patch. The service SHOULD choose the most appropriate way to handle it. Independent of that, the following rules and guidelines apply:

* If for a `+PATCH+` request a property is not given at all, the property MUST be ignored by the backend (i.e. its state remains unchanged).
* If for a `+PATCH+` request a property is given as null, the property MUST be removed by the backend. What this effectively means can be dependent on the underlying stack and/or databases, e.g. in a RDBMS this means the column value will be set to null whereas within a MongoDB the property might be completely removed from the document.
* A service MAY support parts of JSON Patch if it is sufficient to implement the required functionality. The API documentation however should state this fact and preferably describe exactly what parts of the functionality can be used by clients.

[[RESTAPIGuidelines-Standardrequestheaders]]
=== Standard request headers

(Content published by Microsoft can be found https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md#75-standard-request-headers[here].)

Additionally:

[cols=",,"]
|===
|com.bosch.correlationId |UUID |Vendor-specific https://inside-docupedia.bosch.com/confluence/display/ILP/Correlation+ID+Concept[correlation-id for connected industry platform services]
|===

[[RESTAPIGuidelines-Standardresponseheaders]]
== 7.5. ##Standard response headers

Services SHOULD return the following response headers, except where noted in the "required" column.

[cols=",,,"]
|===
|Content-Type |Content type |Mime type of response body (GET/PUT/POST/DELETE) |Haken)]
|com.bosch.correlationId |UUID |Vendor-specific https://inside-docupedia.bosch.com/confluence/display/ILP/Correlation+ID+Concept[correlation-id for connected industry platform services] |Haken)]
|Location |URL |For POST requests to collection resource with result code https://httpstatuses.com/201[201 "Created"] |Fehler)]
|WWW-Authenticate |String |The "https://tools.ietf.org/html/rfc7235#section-3.1[WWW-Authenticate]" header field indicates the authentication scheme(s) and parameters applicable to the target resource. |Fehler)]
|===


In addition to the table above, the following security relevant headers are RECOMMENDED for services that are directly used in combination with a web frontend:

[width="100%",cols="34%,33%,33%",]
|===
|Content-Security-Policy |https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#csp a|
Depends on the service and under which domain the UI is running. Details and examples can be found https://content-security-policy.com/[here].

Angular requires to allow inline styles (CSP policy example: style-src 'unsafe-inline')!

|Referrer-Policy |https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#rp |Referrer-Policy: no-referrer
|X-Content-Type-Options |https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#xcto |X-Content-Type-Options: nosniff
|X-Frame-Options |https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#xfo |X-Frame-Options: sameorigin
|X-Permitted-Cross-Domain-Policies a|
https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#xpcdp

Only required in the context of providing PDF and using Adobe Flash Player

|X-Permitted-Cross-Domain-Policies: none
|X-XSS-Protection |https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#xxxsp |X-XSS-Protection: 1; mode=block
|===

[[RESTAPIGuidelines-Responseformats]]
== Response formats

For organizations to have a successful platform, they MUST serve data in formats developers are accustomed to using, and in consistent ways that allow developers to handle responses with common code.

Web-based communication, especially when a mobile or other low-bandwidth client is involved, has moved quickly in the direction of JSON for a variety of reasons, including its tendency to be lighter weight and its ease of consumption with JavaScript-based clients. Related to that:

* JSON property names SHOULD be camelCased
* Services SHOULD provide JSON (Unicode UTF-8) as the default encoding

[[RESTAPIGuidelines-Clients-specifiedresponseformat]]
=== Clients-specified response format

(Content published by Microsoft can be found https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md#7101-clients-specified-response-format[here].)

[[RESTAPIGuidelines-Errorconditionresponses]]
=== Error condition responses

The discussion on what should be delivered as content with an error or fault (4xx or 5xx) is a controversial one. Returning only a generic message is good in terms of information security because no internal details are exposed via the API. For support on the other hand it is difficult because problem reports from client services do not indicate any specific cause information. A service should not expose exceptions or stack dumps, as this is revealing too much internal information. A formatted useful non-generic error message should accompany any error result code if possible.

For non-success conditions, developers SHOULD be able to write one piece of code that handles errors consistently across different APIs. This allows building of simple and reliable infrastructure to handle exceptions as a separate flow from successful responses. The following is based on the OData v4 JSON spec. However, it is very generic and does not require specific OData constructs. APIs SHOULD use this format even if they are not using other OData constructs.

We recommend that for any transient errors that may be retried, services SHOULD include a Retry-After HTTP header indicating the minimum number of seconds that clients SHOULD wait before attempting the operation again. +

[[RESTAPIGuidelines-ErrorPrecedence]]
==== Error Precedence

Inside a service it can happen that both an error occurs with a request (4xx) and an exception is thrown that indicates an internal error (5xx).

Example: A service validates the content of a request and the validation fails for a part of the request objects. At that point, the service would return a 4xx. But the processing continues and an unrecoverable exception happens. Which error result code should the service return now?

Therefore, we define the following error precedence:

500 < 503 < 4xx

This means when a 4xx error occurs it MUST be returned, even if a 5xx happens after that. An unavailable service should be reported rather than an own internal error. The rationale is that an external error (in request content or external dependency) could be corrected before the client comes back, re-sending the request, and falls into the own internal error condition. Important is what the client gets, not what is good for support. +
The case that a 5xx is returned could still happen in exception cases although a 4xx should have been returned according this rule.

[[RESTAPIGuidelines-ErrorObject]]
==== #Error Object#

For 4xx Client errors or 5xx Server errors a service MUST return some indication of what went wrong. A service MUST return exactly one Error object, preferable as content-type `+application/json+`. The problem is that normally a request concerns one object therefore one error is ok. But in other cases a request included multiple objects and some could have been successful processed while processing others failed. In this case the error response needs to specify on which objects the operation succeeded and on which it failed with corresponding details. This will be done as part of the list of details error objects.

Attributes of an "Error" object:

[cols=",,,"]
|===
|code |String |One of a server-defined machine processable code |Fehler)]
|message |String |A human-readable representation of the error. It is intended as an aid to developers and is not suitable for exposure to end users. Services SHOULD NOT localize "message" for the end user, because doing so might make the value unreadable to the app developer who may be logging the value, as well as make the value less searchable. |Haken)]
|path |String |Relative resource path on which the error occurred (e.g. `+/api/machines/1+`). If query parameters have been given they SHOULD be included, except if they are security relevant |Haken)]
|details |Map<String, Object> |Detailed information excluding any security relevant information. The value MUST be a scalar value in order to avoid different, possibly nested, objects which could greatly complicate the consumption of the error response. Further to support an easy message localization in a UI it is RECOMMEND to provide related placeholder values combined with proper keys. Together with the code the message could be localized in the UI without any string parsing. |Fehler)]
|===

The request response MUST contain an error objects:

*Response containing an error*

[,JSON]
----
{
  "error": {
    "code": "CREATE_ADDRESS_LIMIT"
    "message": "Not allowed to create more than 10 addresses in the current account.",
    "path": "/api/v1/address",
    "details": {
        "msgMaxAddressLimit": 10,
        "timestamp": "2018-06-11T12:56:29.625+0000"
      }
  }
}
----

We recommend that for any transient errors that may be retried, services SHOULD include a Retry-After HTTP header indicating the minimum number of seconds that clients SHOULD wait before attempting the operation again.

IMPORTANT: For a https://tools.ietf.org/html/rfc7235#section-3.2[401] and https://tools.ietf.org/html/rfc7235#section-3.1[407] no error message MUST be sent. For more details see https://tools.ietf.org/html/rfc7235#section-4.1[WWW-Authenticate].

[[RESTAPIGuidelines-HTTPStatusCodes]]
=== HTTP Status Codes

Standard HTTP Status Codes MUST be used; see the https://en.wikipedia.org/wiki/List_of_HTTP_status_codes[HTTP Status Code] definitions for more information.

[[RESTAPIGuidelines-Clientlibraryoptional]]
=== Client library optional

Developers MUST be able to develop on a wide variety of platforms and languages, such as Windows, MacOS, Linux, C#, Python, Node.js, and Ruby.

[[RESTAPIGuidelines-Serverguidance]]
=== Server guidance

A service may decide how to handle undefined properties that are contained in the payload. In general, it is a good practice to accept but ignore them. A 400 Bad Request is valid though if good reasons exist for why additional (unknown) properties are not allowed. This is known as the Robustness Principle: "Be conservative in what you do, be liberal in what you accept from others". A service may render optional properties as null if they are not set.

Special care should be taken however if PATCH operations are offered. As a property that is explicitly set to null will be removed, behavior unexpected by a client may occur if the received payload is used as a base for a subsequent PATCH request. If a service offers PATCH support, optional properties that are not set should not be rendered in responses at all.

[[RESTAPIGuidelines-ReservedURLQueryParameters]]
=== Reserved URL Query Parameters

Below is a list of reserved URL query parameters. There are optional but If used, it MUST be used according to the description of the related query parameter in the table below.

[cols=","]
|===
|`+filter+` |Used to define a RQL query. For more details see "Resource Query Language (RQL)".
|`+option+`# |Used to define additional options for a RQL query. For more details see "Resource Query Language (RQL)".#
|`+select+` |Used to define a projection for a RQL query. For more details see "Resource Query Language (RQL)".
|`+sort+` |Used to define the field for which a list of object will be sorted.
|`+start+` |Used in terms of paging and where to start
|`+count+` |Used in combination with start to define the count of object which should be returned
|`+totalItemCount+` |Used in terms of paging and filtering to explicitly request the total number of items
|===

=== Always Return JSON Objects As Top-Level Data Structures To Support Extensibility

In a response body, you MUST always return a JSON object (and not e.g. an array) as a top level data structure to support future extensibility. JSON objects support compatible extension by additional attributes. This allows you to easily extend your response and e.g. add pagination later, without breaking backwards compatibility.

In addition to that, security-vise (see http://haacked.com/archive/2009/06/25/json-hijacking.aspx/[http://haacked.com/archive/2009/06/25/json-hijacking.aspx]) using a JSON Array as direct return is critical. Instead of returning:

[,JSON]
----
[
 { "id":1, "item": "banana"},
 { "id":2, "item": "minion"}
]
----

You MUST do this instead
[,JSON]
----
{
 "items":
 [
  { "id":1, "item": "banana"},
  { "id":2, "item": "minion"}
 ]
}
----


[[RESTAPIGuidelines-Sub-resource]]
=== Sub-resource

Use *sub-resources* if their *life cycle is coupled to the main resource*, i.e. the main resource works as collection resource of the sub-resource entities or If a sub-resource is only accessible via its parent resource and may not exist without parent. Further, you SHOULD NOT use more than 3 sub-resource (nesting) levels - more levels increase API complexity and too long url path length.

When working with sub-resources it has to distinguish between the main resource and the sub-resources. When the main resource does not exist a 404 Unavailable is expected. When the sub-resource by a GET returns an array of objects or strings but the resource does not have any sub-resources (related data), an empty array SHOULD be returned (_{"items": []}_). Further, when the sub-resource usually returns an object, an empty object "_{}_" MUST be returned. In both cases the non-existence is usually not an error, therefore a 200 OK SHOULD be returned.

[[RESTAPIGuidelines-ServiceResources]]
== Service Resources

[cols=",,,",]
|===
|GET |`+/+` |Landing page shows an HTML entry page with the list of supported API versions, links to the API and user documentation. |Fehler)]
|GET |`+/doc+` |General getting started/user documentation for service as HTML resource, containing potentially sub-pages |Fehler)]
|GET |`+/doc/api+` |Shows the latest API documentation of the service |Fehler)]
|GET |`+/doc/api/{version}+` |Shows the desired API documentation of the service |Fehler)]
|GET |/static |Context for static content for JS, images and other content for the user and the API documentation |Fehler)]
a|
GET

|/health a|
IMPORTANT: Subject to change

Health information of the service which returns:

200 if service status is up
503 if service status is down

and

the response payload contains a JSON document with the property "status" with the value "UP" or "DOWN".

*Example Response:*
[,JSON]
----
{"status":"DOWN"}
----
In case of a successful authentication, the response MAY include additional details of sub systems.

*Example Response:*
[,JSON]
----
{
    "status": "UP",
    "details": {
        "diskSpace": {
            "status": "UP",
            "details": {
                "total": 31158935552,
                "free": 7801958400,
                "threshold": 10485760
            }
        },
        "db": {
            "status": "UP",
            "details": {
                "database": "Microsoft SQL Server",
                "hello": 1
            }
        },
        "authServer": {
            "status": "UP"
        }
    }
}
----
The current approach is intended to get the overall health status of a system. In case of a redundant setup of nodes, additional information is required to allow to address an individual node to get the related health details.

|Haken)]
a|
GET

|/info a|
Static information of the service e.g. the commit hash

WARNING: As per Security Guild meeting in CW4/2021 this endpoint (if provided) has to be restricted to authenticated users/services.#

|Fehler)]
|===

[[RESTAPIGuidelines-CORS]]
== CORS

(Content published by Microsoft can be found https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md#8-cors[here].)

[[RESTAPIGuidelines-Collections]]
== Collections

A collection resource MUST always return a response in the following structure. Paging related properties are all optional as a resource might not support paging at all, for more details see https://inside-docupedia.bosch.com/confluence/display/BCID/REST+API+Guidelines#RESTAPIGuidelines-BCIRESTAPIGuidelines-Paging[Paging]. +

[cols=",,,,<,",]
|===
|items |List of entities returned by service, possibly empty. |Array of items |Haken)] |Haken)] |Haken)]
|totalItems |Number of total existing items |Number |Fehler)] |Fehler)] |Fehler)]
|totalPages |Number of total pages that could be returned by the service |Number |Fehler)] |Fehler)] |Fehler)]
|currentPage |Number of the current page |Number |Fehler)] |Haken)] |Fehler)]
|pageSize |Number of items per page |Number |Fehler)] |Haken)] |Fehler)]
|order |Order of the items which could be one field or multiple fields separated by comma |String |Fehler)] |Fehler)] |Fehler)]
|_links |HATEOAS links according to http://stateless.co/hal_specification.html[HAL] to simplify the navigation through the items of the collection |Object |Fehler)] |Fehler)] |Fehler)]
|===

*Example*

`_GET /.../resources_`
[,JSON]
----
{
    "items": [
       {...}
    ]
}
----

== Resource Query Language (RQL)

(Content published on GitHub can be found https://github.com/persvr/rql[here].)


RQL is a query language designed for use in URIs with object style data structures. It is RECOMMENDED to use Resource Query Language (https://github.com/persvr/rql[RQL]) in combination with a GET or a POST request for supporting a more complex and flexible way of querying/searching, sorting, paging, filtering and projection. If a flexibility which RQL provides is not required, considering usage of just URL query parameters (for more details, see the desired chapter e.g. sorting and Reserved URL Query Parameters).

The following example shows a query using projection to restrict the response payload to the properties name and currentPressure using `+select+` and query overall for data of type "pressure" where the current pressure is under 10 bar using `+filter+` and finally sort the result by name using `+sort+`. +
----
/api/{api-version}/{tenant-id}/{resource-path}?select=name,currentPressure&filter=and(eq(type,"pressure"),lt(currentPressure,10))&option=sort(+ name)&totalItemCount=true
----

The following table show a common set of possible operations an API SHOULD support:

[cols=",,,",]
|===
|`+and+` |(<query>,<query>,...) |filter |Applies all the given queries
|`+or+` |(<query>,<query>,...) |filter |The union of the given queries
|`+eq+` |(<property>,<value>) |filter |Filters for objects where the specified property's value is equal to the provided value
|`+lt+` |(<property>,<value>) |filter |Filters for objects where the specified property's value (of the type number or timestamp) is less than the provided value.
|`+gt+` |(<property>,<value>) |filter |Filters for objects where the specified property's value (of the type number or time) is greater than the provided value
|`+ne+` |(<property>,<value>) |filter |Filters for objects where the specified property's value is not equal to the provided value
|`+in+` |(<property>,<array-of-values>) |filter |Filters for objects where the specified property's value is in the provided array.
|`+out+` |(<property>,<array-of-values>) |filter |Filters for objects where the specified property's value is not in the provided array.
|`+select+` |(<property>,<property>,...) |select |Trims each object down to the set of properties defined in the arguments which allows to effectively reduce the response payload.
|`+sort+` |(<+\|-><property) |option |Sorts by the given property in order specified by the prefix (+ for ascending, - for descending)
|`+limit+` |(start,count) |option a|
Returns the given range of values
[cols=",",]
!===
!`+start+` !Starting index/page
!`+count +` !Number of items which shall be returned
!===

Example:

----
select=id,user.name&filter=ge(id,4711)&option=sort(+user.name,-description),limit(10,5)
----

The example query above limits to 5 results starting at result 10

|===

General not supported are:

* Short variant to define a query e.g. &type="pressure"&currentPressure=lt=10
* All kind of aggregation operators like min or max for the sake to reduce critical performance impact of not optimized queries

Operators which are not supported by the API a 400 Bad Request MUST be returned.

NOTE: For more details, see https://inside-docupedia.bosch.com/confluence/display/BCID/BCI-RQL[BCI-RQL] (https://inside-docupedia.bosch.com/confluence/download/attachments/794200060/rql-documentation-1.0.0-M2-Core3-documentation.pdf?version=1&modificationDate=1549811745000&api=v2[rql-documentation-1.0.0-M2-Core3-documentation.pdf]) which is a collection of libraries to create, parse and process a local dialect of RQL.

[[RESTAPIGuidelines-QueryincombinationwithPOST]]
=== Query in combination with POST

Related to that#, the provided RQL query must be provided as JSON where the actual query is provided as string:
[,JSON]
----
{
  "query":
    // for query-endpoints accepting large bodies through POST, e.g. RQL
    "select=id,name&filter=ge(id,4711)&option=sort(+name,-description),limit(10,5)"
}
----

== Sorting, Paging and Filtering

REST APIs usually have a collection resource to list all entities of a type. In order to give the client more control about how many and which resources it wants to retrieve, collection resources offer query parameters to filter, sort and page the content. The order of processing these query parameters in the service is always:

. filter - reduce the amount of entities by some criteria
. sort - order by an attribute ascending or descending
. page - return just a subset of the data

This applies to root resources but also to sub-resources, if there is an undefined quantity per root resource, e.g. property definitions for a device.

[[RESTAPIGuidelines-Sorting]]
=== Sorting

Related to the underlying persistence of a service, results are by default returned unsorted.

*Using RQL*
----
sort(+field1,-field2)
----

*Using the simple approach (SQL Style)*
----
sort=-field-1,+field-2
----

+ for "asc" and - for "desc"

The response SHOULD contain a self-description of how it is ordered, as an expression string.

*Response using RQL*

`_GET /.../resource?option=sort(+field1,-field2)_`
[,JSON]
----
{
    "items": [
        {...}
    ],
    "order": "+field1,-field2"
}
----


*Response using the simple approach (SQL style)*

`_GET /.../resource?sort=+field1,-field2_`
[,JSON]
----
{
    "items": [
        {...}
    ],
    "order": "+field1,-field2"
}
----

If paging is used a sort order SHOULD be applied on the backend, even if the client did not specify it. The server can decide a default sort attribute and order but needs to tell this to the client by means of the "order" property.

[[RESTAPIGuidelines-Paging]]
=== Paging

Paging is a strategy to divide possible large results into smaller parts (e.g. pages) and retrieving them one by one on demand. Possible implementation approaches are:

* Offset-based paging
* Cursor-based paging
* Time-based paging

The ability to page through results implies that the items are always sorted. Thus, it is RECOMMENDED that a service defines a default sorting field and a limit for the max. number of items the service returns. If such a limit is hit and the client did not request paging explicitly the response should nevertheless contain paging information to indicate to the client not all items have been returned (server-driven paging). Otherwise, the client can also specify paging parameters to get only a desired subset of items (client-driven paging).

==== Offset-based paging

Retrieving data with offset-based paging, you allow clients to supply two additional parameters in their query: an offset, and a count of items. An offset to start from which is simply the number of pages which are intended to be skipped before the actual items. +

*Example with RQL*
----
limit(start, count)
----

*Simple with url query parameters*
----
start={index}&count={count} // RQL related. If RQL is already used as part of the API, this variant is recommended to avoid using different terminologies for the same purpose here offset-based paging.

or

page={index}&pageSize={count}
----

[width="100%",cols="22%,11%,55%,12%",]
|===
|start or page |Number |Starting index which is starting by 0# |Fehler)]
|count or pageSize |Number |Number of items to return per call. + |Fehler)]
|totalItemCount |Boolean |Flag that indicates that the total counts# should be returned |Fehler)]
|===

The count parameter will give the client the opportunity to define the desired number of items which SHOULD be returned. If the max. number is smaller than the given one only the default number of items will be returned. Further it is RECOMMENDED to consider to provide suited HATEOAS links (e.g. "next", see above). This gives the client the indication there is a next page and also a very convenient way to request the items.

In all cases the content of the response needs to indicate how many items have been returned by the query, for more details please see https://inside-docupedia.bosch.com/confluence/display/BCID/REST+API+Guidelines#RESTAPIGuidelines-Collections[Collections]. Therefore, the returned content is a map of paging properties and "items". To avoid that either an array of items directly or a response object with paging and sorting properties is returned, the response object should always be returned as response to list/find operations!

*Sample of JSON response with paging information*

`_GET /.../resource?start=2&count=15&totalItemCount=true_`
[,JSON]
----
{
    "currentPage": 2,
    "totalPages": 10,
    "pageSize": 15,
    "totalItems": 150,
    "order": "+field1,-field2",
    "items": [
       {...}
    ]
}
----

If using http://stateless.co/hal_specification.html[HAL], HAL defines a property "_links" that contains HATEOAS links for an entity. A lot of these relation names are standardized by http://www.iana.org/assignments/link-relations/link-relations.xhtml[IANA rels]. Among them are paging relations "first", "prev", "next" and "last". The links returned would contain the service URLs including the corresponding RQL limit expressions. Especially the "next" and "prev" links give a client service an important indication that there is more content when traversing a resource collection. When the total counts are left out, these links are required! +

*Example Response including HAL Links*

[,JSON]
----
{
    "items": [
       {...}
    ],
    "order": "+field1,-field2",
    "_links": {
        "self": {
            "href": "http://example.org/api/user?start=3"
        },
        "first": {
            "href": "http://example.org/api/user"
        },
        "prev": {
            "href": "http://example.org/api/user?start=2"
        },
        "next": {
            "href": "http://example.org/api/user?start=4"
        },
        "last": {
            "href": "http://example.org/api/user?start=133"
        }
    }
...
}
----

If a link does not make sense, e.g. the "last" link on the last page, then the link should be completely left out. Avoid "null" values in general!

[cols=",,",]
|===
|self |relative URL to current resource or collection |Fehler)]
|first |relative URL to first resource of collection |Fehler)]
|prev |relative URL of previous page in resource collection |Haken)] if there are more pages before
|next |relative URL of next page in resource collection |Haken)] if there are more pages after
|last |relative URL of last page in resource collection |Fehler)]
|===

==== Cursor-based paging

For a cursor-based paging a cursor is a unique identifier for a specific item, which is used as a pointer we want to start querying from to get the next items. Cursor-based paging is very helpful in scenarios where it is required to handle high volume collections which will be updated very frequently. If a collection resource is supporting a cursor-based approach the response payload MUST be as follows:

`_GET /.../resource?after=4a65011d-0294-42cb-8f06-8f6a8b9284b3&count=100&totalItemCount=true_`
[,JSON]
----
{
  "items": [
     {...}
  ],
  "totalItems": 15000,
  "cursor": {
    "before": "9f7a0ae4-6c5b-42ba-9658-932d295ab082",
    "after": "4a65011d-0294-42cb-8f06-8f6a8b9284b3"
  },
  "_links": {
    "previous": "http://example.org/api/user?before=9f7a0ae4-6c5b-42ba-9658-932d295ab082",
    "next": "http://example.org/api/user?after=4a65011d-0294-42cb-8f06-8f6a8b9284b3"
  }
}
----

If a link does not make sense, e.g. the "next" link on the last page, then the link should be completely left out. Avoid "null" values in general!

|===
|previous |URL |URL to request the previous items. An empty value indicates there are no previous items. |Haken)] if not the first item
|next |URL |URL to request the next items. An empty value indicates there are no other items. |Haken)] if items left
|before |String |This is the cursor that points to the start of the page of items that has been returned |Haken)] if not the first item
|after |String |This is the cursor that points to the end of items that has been returned |Haken)] if items left
|count |Number |Number of items to return per call |Fehler)]
|totalItemCount |Boolean |Flag that indicates that the total counts should be returned + |Fehler)]
|===

If no cursor parameter do pass but a count parameter, the default value retrieves the first portion of results.

Cursor-based paging is usually better and more efficient compared to offset-based paging. Especially when it comes to high-data volumes and or storage in NoSQL databases. Before choosing cursor-based pagination, consider the following trade-offs:

* Offset-based paging with start and limit is more known than cursor-based pagination, so may it has better framework support and is easier to use for API clients
* If jump to a certain page in a range (e.g., 10 of 100) is a requirement and needs to support, cursor-based navigation is not feasible
* Variability of data may lead to anomalies in result pages
** Offset-based pagination may create duplicates or lead to missing entries if rows are inserted or deleted between two subsequent paging requests.
** When using cursor-based pagination, paging cannot continue when the cursor entry has been deleted while fetching two pages
* Related to performance and efficient server-side processing using offset-based pagination is hardly feasible for:
** Higher data list volumes, especially if they do not reside in the database’s main memory
** Sharded or NoSQL databases

[[RESTAPIGuidelines-Filtering]]
=== Filtering

*Using RQL*
----
filter="and(lt(property1,value1),eq(property2,value2))"
----

*Using the simple approach*
----
property1=value1&property2=value2
----

RQL allow more complex expressions of course and is recommended to be used when and, or, not and other operations are necessary.

=== Projection (field selection)

Projection allows the consumer of the resource to restrict the information (fields) which will be returned in the response. To realize projection we RECOMMEND to use the RQL syntax:

----
select=property2,property3
----


In the example above only the two defined properties will be part of the response payload no matter if the entity contains a lot more.

[[RESTAPIGuidelines-HATEOAS]]
== #HATEOAS

HATEOAS (Hypermedia As The Engine Of Application State) is one of the more advanced but basic principles of REST. It allows a client to dynamically navigate the content of a site or service (discoverability).

While this is not a MUST functionality it is highly desirable and helps in many cases such as https://inside-docupedia.bosch.com/confluence/display/BCID/REST+-+Sorting%2C+Paging+and+Filtering[paging].

[[RESTAPIGuidelines-HAL]]
=== 12.1. ##HAL

To realize HATEOS in a very simple and easy way we RECOMMEND to use http://stateless.co/hal_specification.html[HAL (Hypertext Application Language)]. HAL is adds HATEOAS links to the normal resource in parallel and also allows to optionally embed linked resources:

* HAL adds a property "_links" with a map of links and an optional "_embedded" property to the standard JSON payload of a response (the state).
* If a response does not contain any link, the "_links" property can be left away (optional according to the https://tools.ietf.org/html/draft-kelly-json-hal-08[HAL standard]).

The link relations (keys/property names of the "_links" map) are either standard according to the https://www.iana.org/assignments/link-relations/link-relations.xhtml[IANA list] or custom. It is highly RECOMMENDED to use standard relations if possible.


=== Relative URLs

The URLs included in the payload of a response in HATEOAS, can be harmful in some case. One is the use of API gateways. The API gateway hides the original hostname behind a single entrypoint with a new externally visible hostname. The problem is now, that the links generated by backend services would still reference the hostname, that the service knows.

There are multiple ways around this, including URL rewriting. But we regard this as an error-prone mechanism that would also limit the gateways that could be used and might also impact performance and flexibility. Therefore, we would like to avoid this problem by using relative HATEOAS links whenever possible. There are cases of course, when a HATEOAS link points to another service, where a relative link would be impossible.

[[RESTAPIGuidelines-Throttling,Quotas,andLimits]]
== Throttling, Quotas, and Limits

(Content published by Microsoft can be found https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md#14-throttling-quotas-and-limits[here].)

[[RESTAPIGuidelines-JSONstandardizations]]
== JSON standardizations

(Content published by Microsoft can be found https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md#11-json-standardizations[here].)

Additionally:

* for date and time, see also http://apiux.com/2013/03/20/5-laws-api-dates-and-times/

[[RESTAPIGuidelines-Versioning]]
== Versioning

All APIs MUST consider to use an explicit versioning with a granularity of major versions e.g. ".../api/v1/..." . It's critical that clients can count on services to be stable over time, and it's critical that services can add features and make changes. Further, the API version is independent of the major or minor version of the service itself. A service could have major version 5 and implement the API versions v1 and v2. Note also, that the API version is different from the version of the data contract potentially. Further, the version of the data will be changing more often than the API version.

General when it comes to the point the API needs to change, we RECOMMEND to do that in a compatible way and avoid generating additional API versions. Multiple versions can significantly complicate understanding, testing, maintaining, evolving, operating and releasing of the service (http://martinfowler.com/articles/enterpriseREST.html[supplementary reading]).

If changing an API can’t be done in a compatible way, then proceed in one of these three ways:

* create a new resource (variant) in addition to the old resource variant
* create a new service endpoint — i.e. a new application with a new API (with a new domain name)
* create a new API version supported in parallel with the old API by the same microservice

IMPORTANT: As we discourage versioning by all means because of the manifold disadvantages, we strongly RECOMMEND to only use the first two approaches. Keep compatible changes out of names.

=== When to version

(Content published by Microsoft can be found https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md#122-when-to-version[here].)

=== Definition of a breaking change

Changes to the contract of an API are considered a breaking change. Changes that impact the backwards compatibility of an API are a breaking change. Teams MAY define backwards compatibility as their business needs require.

Examples of breaking changes:

. Removing or renaming APIs or API parameters
. Changes in behavior for an existing API
. Changes in error codes and fault contracts
. Anything that would violate the http://en.wikipedia.org/wiki/Principle_of_least_astonishment[Principle of least astonishment]

== Naming guidelines

=== Approach

Naming policies should aid developers in discovering functionality without having to constantly refer to documentation. Use of common patterns and standard conventions greatly aids developers in correctly guessing common property names and meanings. Services SHOULD use verbose naming patterns and SHOULD NOT use abbreviations other than acronyms that are the dominant mode of expression in the domain being represented by the API, (e.g. Url).

[[RESTAPIGuidelines-Casing]]
=== Casing

* Resource names should be subjects in lower case (no camel-case).
* If resource names or query parameters get longer and including more than 2 words SHOULD to use spinal-case (e.g. ultra-long-resource-name-that-would-be-unreadable-otherwise).
* JSON property names MUST be camelCased.
* HTTP headers are the exception and SHOULD use standard HTTP convention of Capitalized-Hyphenated-Terms.

[[RESTAPIGuidelines-Namestoavoid]]
=== Names to avoid

Certain names are so overloaded in API domains that they lose all meaning or clash with other common usages in domains that cannot be avoided when using REST APIs, such as OAuth2. Services SHOULD NOT use the following names:

* Context
* Scope
* Resource

[[RESTAPIGuidelines-Caching]]
== Caching

Optionally, if the API MAY support conditional GET requests. This will allow a web client to cache resource representations and effectively reduce the data sent over the wire. For conditional GET requests to work, the client MUST send the http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.19[ETag] value when requesting resources using the http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.26[If-None-Match] request header. The ETag is the one provided by a previous request to that same URI.

The server should acknowledge the `+If-None-Match+` header and check whether the response should be a `+304+` (Not Modified).

[[RESTAPIGuidelines-Batchrequest]]
== Batch request

(Content published by Microsoft can be found https://docs.microsoft.com/en-us/graph/json-batching[here].)

Additionally:

* If offered it SHOULD be exposed under a different API name, e.g. `+/batch-api/+`

[[RESTAPIGuidelines-Bulkrequest]]
== Bulk request

Requests which apply one operation specified by the HTTP operation and a URL to a set of entities MUST provide IDs in the payload. Examples for a bulk request is an event API that receive an array of events or a bulk create (POST without ID with multiple objects to create) that creates multiple objects with one request. A bulk request is always restricted to one tenant.

[[RESTAPIGuidelines-APIStructure]]
=== API Structure

If a bulk API will be offered the endpoint SHOULD be exposed under a different API name, e.g. `+/bulk-api/+`. Thus, the resources themselves stay in the same structure as for the "default" API. A special case are `+POST+` query requests that are used to allow sending large payloads. They could be provided under a `+/bulk-api/+` as well.

[[RESTAPIGuidelines-RequestPayload]]
=== Request Payload

Requests to bulk endpoints always provides a body. The actual payload of an individual item MUST be exactly the same as for the single-valued endpoints, except it is an array. The following example show the container structure for a RQL bulk requests:

[,JSON]
----
{
  "options": {
    "resumeOnError": true
  },
  "items": [
    // same as for single-valued endpoints, just as an array
  ],
  "query": {
    // for query-endpoints accepting large bodies through POST, e.g. RQL
  }
}
----

[cols=",,,"]
|===
|Property |Description |Default Value |REQUIRED

|`+resumeOnError+` |Whether the server should continue when single requests fail. |`+false+` |Fehler)]
|`+rollbackOnError+` a|
Whether the server should do a rollback after an error. This works only in combination with resumeOnError set to false otherwise rollbackOnError will be ignored.

We RECOMMEND to consider, if the requirement/business case requires to offer a new resources instead of misusing the existing APIs.

In case you really want to support it, consider the usage of a database transaction to avoid complex rollback implementations.

|`+false+` |Fehler)]
|`+items+` |The list of items for the bulk request. Each element MUST match the structure of the single-valued endpoint. For a `+DELETE+` this is a list of IDs. |N/A a|
Haken)]

either items or query must be provided.

|`+query+` a|
Query to determine the items that should be retrieved or operated on. A query endpoint that is operated through a `+POST+` can e.g. accept an RQL query here. It is also possible to offer this e.g. for a `+DELETE+` endpoint if clients should be able to delete by a search criteria rather than a list of IDs.

Only either `+items+` or `+query+` MUST be given, but neither none of them nor both at once.

|N/A |
|===

[[RESTAPIGuidelines-ResponsePayload]]
=== Response Payload

[[RESTAPIGuidelines-ForQueryRequests]]
==== For Query Requests

For queries, the response shall be a collection response as defined previously.

*Response for bulk request with query*

`_POST /api/v1/someresource 200 with Query in Body_`
[,JSON]
----
{
    "items": [
       {...}
    ]
}
----

[[RESTAPIGuidelines-Formulti-itemrequests]]
==== For multi-item requests

The response structure is besides the id the same as for batch requests. In both scenarios the client MUST be able to map the response result for every item as it is possible for a single request.

*Response for multiple entries deleted*

`_DELETE /api/v1/someresource 204_`
[,JSON]
----
{
  "responses": [
    {
      "status": 204
    },
    {
      "status": 204
    }
  ]
}
----

*Response for multiple entries created*

`_POST /api/v1/someresource 201_`
[,JSON]
----
{
  "responses": [
    {
      "body": {
        "description": "..."
      },
      "status": 201
    },
    {
      "body": {
        "description": "..."
      },
      "status": 201
    }
  ]
}
----

When a bulk API returns results including different success and/or error status (mix of result codes), it should return https://httpstatuses.com/207[207 "Multi-Status"], to indicate that the client needs to look into the response to find the response code of the corresponding entity. In the payload the client should find a JSON structure, that contains a status and errors for at least the failed objects or events.

To be discussed / TODO:

* API documentation tools tend to show 207 as success, but actually it may as well indicate errors
* Microsoft always returns 200, independent of the individual response status - so body always has to be inspected
* Many HTTP client libraries interpret 2xx as success natively, so custom handling is typically always required for 207 → so maybe it could just be the default for bulk-responses independent of the contained response statuses.

*Response for created multiple entries including errors*

`_POST /api/v1/someresource 207_`
[,JSON]
----
{
  "results": [
    {
      "status": 201,
      "body": {
         "id": "80be2ba0-bf02-4d60-aba8-46384036feba"
      }
    },
    {
      "status": 400,
      "body": {
        "error": {
           "message": "Multiple errors creating address",
           "path": "/api/address/v1",
           "details": {
              "timestamp": "2018-06-11T12:56:29.625+0000"
           }
        }
      }
    },
    {
      "status": 201,
      "body": {
         "id": "0905424a-6fef-4c25-a712-033418517f02"
      }
    },
  ]
}
----

NOTE: The items MUST be in the same order as provided in the request payload or query. This allows the client to easily determine if the operation succeeded or failed. Additionally, query endpoints MUST return the structure as defined in chapter Sorting, Pagination and Filtering.

[[RESTAPIGuidelines-FAQ]]
== FAQ

=== How to handle entity already exist (400, 409 vs 422)?

If a technical key is violated when creating a resource/entity, there are many discussions about which HTTP status code should be returned. This is the typical error case if the entity already exists. Many APIs return 409 "Conflict" ins such situation. The advocates get prominent support from Google which uses 409 as well. Strictly speaking, it is not a conflict because there are no parallel requests. That's why also many APIs return the status code 400. Both are too general and do not make what the issue really is. Thus, an API in such a case SHOULD return 422 "Unprocessable Entity" which more clearly distinguishes this problem from bad request parameters.

=== When to return 404?

* Whenever the target resource does not exist, the backend MUST return a 404, no matter what the HTTP verb was.
* If the request is some sort of query or filter that produces an empty result, the operation was successful but the result is empty. In those cases the backend MUST NOT return a 404.
* In case a client for whatever reason issues multiple DELETEs on the same resource, all subsequent requests should return a 404 as well. A backend however MAY return 410 "Gone" when another DELETE is issued on the same resource if this sort of context relevant to a client.

Example: Searching for non-existing person 1 return 404

`_GET api/persons/\{person-id\}_`

`_GET api/persons/1_`


Example: Searching and Filtering for all persons (collection response) with name foo. For alle collections response return an empty collection set

`_GET api/persons?filter=eq(name,"foo")_`
----
{
    "itemCount": 0,
    "items": []
}
----

=== How to only get the total count of items for a collection resource?

Instead of offering an additional resource/sub-resource to only allow to get the total count, a collection resource could be used in combination with explicitly setting the parameter count to 0 and totalItemCount to true. Now the backend could be easily detect the caller is only interested in the total number of existing items and thus, returns only the total number.


=== Should I set a WWW-Authenticate header for 403?

For 403 no WWW-Authenticate header SHOULD be set only for 401 and 407 (see ##https://inside-docupedia.bosch.com/confluence/display/BCID/REST+API+Guidelines#RESTAPIGuidelines-ErrorObject[Error Object]).

Wikipedia: https://en.wikipedia.org/wiki/HTTP_403 or here https://tools.ietf.org/html/rfc7235#section-2.1

If you want to hide the reason you SHOULD return 404. An error code 403 with body `Access is denied` is fine (https://tools.ietf.org/html/rfc7231#section-6.5.3)


=== PUT vs POST if entity does not exist. How can the client supplies the ID?

https://inside-docupedia.bosch.com/confluence/display/BCID/REST+API+Guidelines#RESTAPIGuidelines-Resourcedoesn%27texist[7.3.3.1. (PUT where the entity does not exist.)]

____
This is only allowed for the case where it is mandatory that the client supplies the ID.
____

Normally ID-generation should be a service responsibility. So in general a good practice is *POST = CREATE* and *PUT = REPLACING/UPDATE*

In some edge case the client want to set the id, but POST is NOT idempotent. So if you retry the request N times, you will end up having N resources, which cannot work if you have a POST with ID (cause of duplication).

So in this edge cases this is more a *create-or-update* function and the recommendation is using *PUT* for that.

If you don't need a *create-or-update* it is easier for you, then just use *PUT* for replacing the resource and if the resource is not existing return a 404.

____
Does that mean, we should provide a PUT with POST semantics *only* if the client wants to specify the resource id.
____

Yes
