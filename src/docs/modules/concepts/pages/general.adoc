[[General]]
= General concepts

This section aims at understanding the basic architectural principles of the Nexeed Industrial Application System (IAS) and its valuable foundation components.

[[SCS]]
== Self-Contained Systems
The self-contained systems (SCS) approach aims to create modular, independent, and autonomous systems. An SCS is designed to encapsulate a specific business functionality or a set of related functionalities within a bounded context. It can be thought of as a small, self-sufficient application that can operate independently, while still being able to interact with other systems when necessary.

Why we have chosen an SCS-based architecture:

. *Modularity*: An SCS is a modular unit of software that is responsible for a specific domain or business capability. It encapsulates all the necessary components, such as user interfaces, business logic, data storage, and external integrations, required to fulfill its designated functionality.
. *Bounded Context*: Each self-contained system operates within a well-defined and self-contained bounded context. This means that it has clear boundaries that separate it from other systems, allowing it to evolve independently without affecting or being affected by external changes.
. *Autonomy*: Self-contained systems are autonomous and can function independently. They can be developed, deployed, and scaled independently of other systems. This autonomy helps in achieving a high degree of isolation, allowing teams to work on different systems simultaneously without interfering with each other.
. *Decentralized Governance*: Self-contained systems have their own internal governance mechanisms. Each system can make its own technological choices, such as programming languages, frameworks, and data storage solutions, based on its specific needs. This decentralization empowers teams to make decisions that are best suited for their respective systems.
. *Communication and Collaboration*: Although self-contained systems are designed to be independent, they still need to interact with other systems to form a complete software solution. This is typically achieved through well-defined communication channels, such as APIs or messaging protocols, which enable systems to exchange data and trigger actions.
. *Scalability*: Self-contained systems are designed to be scalable at the individual system level. This means that each system can be scaled independently based on its specific needs, allowing for more efficient resource allocation and improved performance.

NOTE: For more information, check out https://scs-architecture.org/[this] page!

//== Single source of truth

//NOTE: coming soonâ„¢


[[EventDriven]]
== Event-Driven Architecture

Event-driven architecture (EDA) is an architectural pattern in software development that emphasizes the production, detection, and consumption of events as the primary means of communication and coordination between different components or services within a system. In EDA, events are used to trigger actions or notify interested parties about changes or significant occurrences.

Why we have chosen to incorporate an EDA-based architecture:

* *Loose coupling*: EDA promotes loose coupling between components, as they communicate through events rather than direct method invocations. This enhances system flexibility and allows components to evolve independently without impacting other parts of the system.
* *Scalability*: EDA enables horizontal scalability by distributing event processing across multiple consumer instances. This allows the system to handle a large number of events and scale resources based on demand.
* *Flexibility and extensibility*: EDA supports easy integration of new components or services by enabling them to subscribe to relevant events. New functionality can be added simply by introducing new event consumers without modifying existing components.
* *Asynchronous processing*: Events can be processed asynchronously, allowing components to continue their operations without waiting for immediate responses. Asynchronous processing enhances system responsiveness, resilience, and the ability to handle high volumes of events.
* *Real-time capabilities*: EDA facilitates real-time processing and enables real-time decision-making based on events. This is particularly beneficial in scenarios where real-time insights or immediate actions are required.
* *Event sourcing and auditing*: With EDA, events can be logged and stored, providing an audit trail of system activities. This allows for event replay, debugging, and analysis of system behavior over time.

[[MultiTenancy]]
== Multi-Tenancy

Multi-tenancy allows a single instance of an application or system to serve multiple tenants. A tenant refers to a distinct group of users or organizations that share the same software instance while keeping their data and configuration isolated from other tenants.

In multi-tenancy, the application is designed to provide each tenant with a customized experience, while securely segregating their data and ensuring logical separation.

Why we have chosen to build a multi-tenant-capable software system:

. *Resource Efficiency*: Multi-tenancy enables optimal utilization of computing resources. Instead of deploying separate instances of the software for each tenant, a single instance can serve multiple tenants, reducing hardware and infrastructure costs.
. *Lower Maintenance Effort*: With a multi-tenant architecture, software updates, bug fixes, and enhancements only need to be applied once to the shared instance, rather than managing them separately for each tenant. This simplifies maintenance and reduces administrative overhead.
. *Scalability and Elasticity*: Multi-tenancy allows for efficient scaling and elasticity. As the number of tenants or their usage grows, additional computing resources can be provisioned to accommodate the increased demand, benefiting all tenants simultaneously.
. *Customization and Configuration*: Multi-tenancy allows each tenant to have its own customizations and configurations. This means that tenants can have different branding, user interfaces, workflows, business rules, and even feature sets, tailored to their specific requirements, while still sharing the underlying software instance.
. *Isolation and Security*: Multi-tenancy provides logical isolation between tenants, ensuring that their data and configurations remain separate and secure. It employs robust access controls, data encryption, and other security measures to prevent unauthorized access and data leakage between tenants.
. *Rapid Onboarding and Scalability*: Multi-tenancy simplifies the onboarding process for new tenants. With a single shared instance, provisioning a new tenant involves configuring their specific settings, rather than setting up and deploying a whole new instance. This speeds up the deployment process and allows for rapid scalability to accommodate new tenants as needed.


[[InformationModel]]
== Information Model
Most of the static data in our system is designed to be according to the ISA 95 / IEC 62264 standards. We will provide you with a more detailed view on our information model in a future release of this documentation.